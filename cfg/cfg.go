package cfg

import (
	"go/ast"
	"go/token"
	"strconv"

	"golang.org/x/tools/go/cfg"
)

var cnt = 0

type CfgNode struct {
	ast  ast.Node
	id   int
	succ map[Node]struct{}
	pred map[Node]struct{}
}

func newCfg(ast ast.Node) CfgNode {
	cnt++
	return CfgNode{
		ast:  ast,
		id:   cnt - 1,
		succ: make(map[Node]struct{}),
		pred: make(map[Node]struct{}),
	}
}

type Variable = string

func (c *CfgNode) AST() ast.Node {
	return c.ast
}

func (c *CfgNode) Id() int {
	return c.id
}

func (c *CfgNode) Succ() map[Node]struct{} {
	return c.succ
}

func (c *CfgNode) Pred() map[Node]struct{} {
	return c.pred
}

func connect(from, to Node) {
	if from != nil && to != nil {
		from.Succ()[to] = struct{}{}
		to.Pred()[from] = struct{}{}
	}
}

//StartNode represents start of CFG
type StartNode struct {
	CfgNode
}

func NewStartNode() *StartNode {
	return &StartNode{
		CfgNode: newCfg(nil),
	}
}

//AllocNode represents [X = alloc P]
type AllocNode struct {
	CfgNode
	Lhs Variable
}

func NewAllocNode(lhs Variable, ast ast.Node) *AllocNode {
	return &AllocNode{
		CfgNode: newCfg(ast),
		Lhs:     lhs,
	}
}

//RefNode represents [X_1 = &X_2]
type RefNode struct {
	CfgNode
	Lhs Variable
	Rhs Variable
}

func NewRefNode(lhs, rhs Variable, ast ast.Node) *RefNode {
	return &RefNode{
		CfgNode: newCfg(ast),
		Lhs:     lhs,
		Rhs:     rhs,
	}
}

//AssignNode represents [X_1 = X_2]
type AssignNode struct {
	CfgNode
	Lhs Variable
	Rhs Variable
}

func NewAssignNode(lhs, rhs Variable, ast ast.Node) *AssignNode {
	return &AssignNode{
		CfgNode: newCfg(ast),
		Lhs:     lhs,
		Rhs:     rhs,
	}
}

//PointerNode represents [X_1 = *X_2]
type PointerNode struct {
	CfgNode
	Lhs Variable
	Rhs Variable
}

func NewPointerNode(lhs, rhs Variable, ast ast.Node) *PointerNode {
	return &PointerNode{
		CfgNode: newCfg(ast),
		Lhs:     lhs,
		Rhs:     rhs,
	}
}

//DerefNode represents [*X_1 = X_2]
type DerefNode struct {
	CfgNode
	Lhs Variable
	Rhs Variable
}

func NewDerefNode(lhs, rhs Variable, ast ast.Node) *DerefNode {
	return &DerefNode{
		CfgNode: newCfg(ast),
		Lhs:     lhs,
		Rhs:     rhs,
	}
}

//NullNode represents [X = null]
type NullNode struct {
	CfgNode
	Lhs Variable
}

func NewNullNode(lhs Variable, ast ast.Node) *NullNode {
	return &NullNode{
		CfgNode: newCfg(ast),
		Lhs:     lhs,
	}
}

//SingleDerefNode represents [*X]
type SingleDerefNode struct {
	CfgNode
	Lhs Variable
}

func NewSingleDerefNode(lhs Variable, ast ast.Node) *SingleDerefNode {
	return &SingleDerefNode{
		CfgNode: newCfg(ast),
		Lhs:	 lhs,
	}
}

func ToString(node Node) string {
	switch n := node.(type) {
	case *StartNode:
		return "[START]"
	case *RefNode:
		return "[" + n.Lhs + " = &" + n.Rhs + "]"
	case *AssignNode:
		return "[" + n.Lhs + " = " + n.Rhs + "]"
	case *PointerNode:
		return "[" + n.Lhs + " = *" + n.Rhs + "]"
	case *DerefNode:
		return "[*" + n.Lhs + " = " + n.Rhs + "]"
	case *NullNode:
		return "[" + n.Lhs + " = null]"
	case *AllocNode:
		return "[" + n.Lhs + " = alloc]"
	case *SingleDerefNode:
		return "[" + n.Lhs + "]"
	default:
		panic("unimplemented print")
	}
}

type Node interface {
	AST() ast.Node
	Id() int
	Succ() map[Node]struct{}
	Pred() map[Node]struct{}
}

type Builder struct {
	//stores first Node generated by this block
	blockNode map[*cfg.Block]Node
	//used for detecting empty cycles
	emptyCycleNodes map[*cfg.Block]struct{}
	freshVarCnt     int

	result *StartNode
}

func NewBuilder() *Builder {
	return &Builder{
		blockNode:       make(map[*cfg.Block]Node),
		emptyCycleNodes: make(map[*cfg.Block]struct{}),
		freshVarCnt:     0,
	}
}

func (b *Builder) sameFreshVar() string {
	return "_t" + strconv.Itoa(b.freshVarCnt)
}

func (b *Builder) nextFreshVar() string {
	b.freshVarCnt++
	return b.sameFreshVar()
}

func (b *Builder) Nodes() []Node {
	var nodes []Node
	start := b.GetCfg()
	visited := make(map[Node]struct{})
	visited[start] = struct{}{}

	for n := range start.Succ() {
		nodes = b.flattenCfg(n, nodes, visited)
	}
	return nodes
}

func (b *Builder) flattenCfg(n Node, nodes []Node, visited map[Node]struct{}) []Node {
	nodes = append(nodes, n)
	visited[n] = struct{}{}

	for s := range n.Succ() {
		if _, ok := visited[s]; !ok {
			nodes = b.flattenCfg(s, nodes, visited)
		}
	}
	return nodes
}

func (b *Builder) Build(block *cfg.Block) {
	b.result = NewStartNode()
	b.blockToNode(block, b.result)
}

func (b *Builder) GetCfg() *StartNode {
	if b.result == nil {
		panic("run build first")
	}
	return b.result
}

func (b *Builder) blockToNode(block *cfg.Block, pred Node) {
	var blockFirst Node = nil //represents first node of this block
	currLast := pred
	for _, astNode := range block.Nodes {
		first, last := b.astToNode(astNode)
		if first != nil {
			connect(currLast, first)
			currLast = last
			//if blockFirst is nil, that means this is first node of this block
			if blockFirst == nil {
				blockFirst = first
			}
		}
	}
	//if current block hasn't created any new node, we will add it to empty cycle-detecting map
	if blockFirst == nil {
		b.emptyCycleNodes[block] = struct{}{}
	} else {
		//clear empty cycle-detecting map - we have non-empty block
		b.emptyCycleNodes = make(map[*cfg.Block]struct{})
		b.blockNode[block] = blockFirst
		connect(pred, blockFirst)
	}
	for _, suc := range block.Succs {
		//check if we're going in empty circles
		_, ok1 := b.emptyCycleNodes[suc]
		if ok1 {
			continue
		}

		n, ok2 := b.blockNode[suc]
		if ok2 {
			connect(currLast, n)
			continue
		}
		b.blockToNode(suc, currLast)
	}
}

//appends node to first-last sequence of nodes and returns a new first-last sequence
func (b *Builder) appendNode(n Node, f Node, l Node) (Node, Node) {
	if f == nil {
		return n, n
	}
	connect(l, n)
	return f, n
}

//returns first and last node created by this AST node
func (b *Builder) astToNode(a ast.Node) (first, last Node) {
	switch a := a.(type) {
	case *ast.AssignStmt:
		//extends current first-last sequence with new nodes and returns new first-last sequence
		first, last = b.assignLhsToNode(a.Lhs[0], a.Rhs[0], first, last)
	case *ast.ValueSpec: //for example [var int* x] or [var int* x = new(1)]
		first, last = b.declToNode(a, first, last)
	default: //all other nodes that can contain SingleDerefNode
		first, last = b.othersToNode(a, first, last)
	}
	return first, last
}

//decomposes lhs of assign statement
func (b *Builder) assignLhsToNode(lhsExp ast.Expr, rhsExp ast.Expr, f Node, l Node) (first, last Node) {
	switch lhs := lhsExp.(type) {
	case *ast.ParenExpr:
		first, last = b.assignLhsToNode(lhs.X, rhsExp, f, l)
	case *ast.Ident:
		first, last = b.assignRhsToNode(lhs.Name, rhsExp, f, l)
	case *ast.StarExpr:
		//check if we need to normalize lhs StarExpr even more
		switch id := lhs.X.(type) {
		case *ast.Ident: //no need to normalize
			//now we'll peek the rhs
			switch rhs := rhsExp.(type) {
			case *ast.Ident:
				return b.appendNode(NewDerefNode(id.Name, rhs.Name, rhsExp), f, l)
			}
			freshVar := b.nextFreshVar()
			newF, newL := b.assignRhsToNode(freshVar, rhsExp, f, l)
			//only if new nodes were created we will append DerefNode
			if newF != f || newL != l {
				first, last = b.appendNode(NewDerefNode(id.Name, freshVar, lhsExp), newF, newL)
			}
		default: //we need to normalize lhs StarExpr
			freshVar := b.nextFreshVar()
			//this will normalize lhs and store it in the freshVar
			f, l = b.assignRhsToNode(freshVar, id, f, l)
			//this will set lhs ast to freshVar (which now represents normalized lhs)
			lhs.X = ast.NewIdent(freshVar)
			first, last = b.assignLhsToNode(lhs, rhsExp, f, l)
		}
	}
	return first, last
}

//decomposes rhs of assign statement
func (b *Builder) assignRhsToNode(lhs string, rhsExp ast.Expr, f Node, l Node) (first, last Node) {
	switch rhs := rhsExp.(type) {
	case *ast.ParenExpr:
		first, last = b.assignRhsToNode(lhs, rhs.X, f, l)
	case *ast.Ident:
		if rhs.Name == "nil" {
			first, last = b.appendNode(NewNullNode(lhs, rhsExp), f, l)
		} else {
			first, last = b.appendNode(NewAssignNode(lhs, rhs.Name, rhsExp), f, l)
		}
	case *ast.UnaryExpr:
		if rhs.Op == token.AND { //&
			switch id := rhs.X.(type) {
			case *ast.Ident:
				first, last = b.appendNode(NewRefNode(lhs, id.Name, rhsExp), f, l)
			default: //recursive normalization for * and &
				freshVar := b.nextFreshVar()
				f, l = b.assignRhsToNode(freshVar, rhs.X, f, l)
				first, last = b.appendNode(NewRefNode(lhs, freshVar, rhsExp), f, l)
			}
		}
	case *ast.StarExpr:
		switch id := rhs.X.(type) {
		case *ast.Ident:
			first, last = b.appendNode(NewPointerNode(lhs, id.Name, rhsExp), f, l)
		default: //recursive normalization for * and &
			freshVar := b.nextFreshVar()
			f, l = b.assignRhsToNode(freshVar, rhs.X, f, l)
			first, last = b.appendNode(NewPointerNode(lhs, freshVar, rhsExp), f, l)
		}
	case *ast.CallExpr:
		//TODO: dunno what to do here..
		//		assume there's no normalization needed and create AllocNode (what if the function returns double pointer)?
		//		I guess for now, yes..
		first, last = b.appendNode(NewAllocNode(lhs, rhsExp), f, l)

		//function call itself can contain SingleDerefNode as argument
		for _, v := range rhs.Args {
			first, last = b.othersToNode(v, first, last)
		}
	}
	return first, last
}

//decomposes variable declaration
func (b *Builder) declToNode(spec *ast.ValueSpec, f Node, l Node) (first, last Node) {
	//first, we need to count the number of * references of spec's type
	refCount := 1 //if type is undefined, we assume that there's one * reference
	stop := false
	if spec.Type != nil {
		specType := spec.Type
		for i := 0; !stop; i++ {
			switch expr := specType.(type) {
			case *ast.StarExpr:
				specType = expr.X
			default:
				refCount = i
				stop = true
			}
		}
	}

	//only create nodes if there is at least one level of * reference
	if refCount > 0 {
		//normalize more than 1 * reference
		currVar := spec.Names[0].Name
		for i := 1; i < refCount; i++ {
			freshVar := b.nextFreshVar()
			f, l = b.appendNode(NewRefNode(currVar, freshVar, spec), f, l)
			currVar = freshVar
		}
		if spec.Values == nil {
			first, last = b.appendNode(NewNullNode(currVar, spec), f, l)
		} else {
			first, last = b.assignRhsToNode(currVar, spec.Values[0], f, l)
		}
	}
	return first, last
}

//decomposes all other nodes
func (b *Builder) othersToNode(a ast.Node, f Node, l Node) (first, last Node) {
	//TODO: find all SingleDerefNode
	return f, l
}